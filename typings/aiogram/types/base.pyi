"""
This type stub file was generated by pyright.
"""
# flake8: noqa
import io
from re import S
import typing
from typing import TypeVar
from .fields import BaseField
from ..utils.mixins import ContextInstanceMixin
from ..bot.bot import Bot

if typing.TYPE_CHECKING:
    ...
__all__ = ('MetaTelegramObject', 'TelegramObject', 'InputFile', 'String', 'Integer', 'Float', 'Boolean')
PROPS_ATTR_NAME = ...
VALUES_ATTR_NAME = ...
ALIASES_ATTR_NAME = ...
InputFile = TypeVar('InputFile', "InputFile", io.BytesIO, io.FileIO, str) # type: ignore
String = TypeVar('String', bound=str)
Integer = TypeVar('Integer', bound=int)
Float = TypeVar('Float', bound=float)
Boolean = TypeVar('Boolean', bound=bool)
T = TypeVar('T')
log = ...

class MetaTelegramObject(type):
    """
    Metaclass for telegram objects
    """
    _objects = ...

    def __new__(mcs: typing.Type[T], name: str, bases: typing.Tuple[typing.Type], namespace: typing.Dict[str, typing.Any], **kwargs: typing.Any) -> T:
        # sourcery skip: class-method-first-arg-name
        ...
    
    @property
    def telegram_types(cls) -> dict[typing.Any, typing.Any]:
        ...
    


class TelegramObject(ContextInstanceMixin, metaclass=MetaTelegramObject):
    """
    Abstract class for telegram objects
    """
    def __init__(self, conf: typing.Dict[str, typing.Any] = ..., **kwargs: typing.Any) -> None:
        """
        Deserialize object

        :param conf:
        :param kwargs:
        """
        ...
    
    @property
    def conf(self) -> typing.Dict[str, typing.Any]:
        ...
    
    @property
    def props(self) -> typing.Dict[str, BaseField]:
        """
        Get props

        :return: dict with props
        """
        ...
    
    @property
    def props_aliases(self) -> typing.Dict[str, str]:
        """
        Get aliases for props

        :return:
        """
        ...
    
    @property
    def values(self) -> typing.Dict[str, typing.Any]:
        """
        Get values

        :return:
        """
        ...
    
    @property
    def telegram_types(self) -> typing.List[TelegramObject]:
        ...
    
    @classmethod
    def to_object(cls: typing.Type[T], data: typing.Dict[str, typing.Any], conf: typing.Dict[str, typing.Any] = ...) -> T:
        """
        Deserialize object

        :param data:
        :param conf:
        :return:
        """
        ...
    
    @property
    def bot(self) -> Bot:
        ...
    
    def to_python(self) -> typing.Dict[str, typing.Any]:
        """
        Get object as JSON serializable

        :return:
        """
        ...
    
    def clean(self) -> None:
        """
        Remove empty values
        """
        ...
    
    def as_json(self) -> str:
        """
        Get object as JSON string

        :return: JSON
        :rtype: :obj:`str`
        """
        ...
    
    @classmethod
    def create(cls: typing.Type[T], *args: typing.Any, **kwargs: typing.Any) -> T:
        ...
    
    def __str__(self) -> str:
        """
        Return object as string. Alias for '.as_json()'

        :return: str
        """
        ...
    
    def __repr__(self) -> str:
        """
        Return object readable representation.

        Example: <ObjectName {"id": 123456}>
        :return: object class name and object data as a string
        """
        ...
    
    def __getitem__(self, item: typing.Union[str, int]) -> typing.Any:
        """
        Item getter (by key)

        :param item:
        :return:
        """
        ...
    
    def __setitem__(self, key: str, value: typing.Any) -> None:
        """
        Item setter (by key)

        :param key:
        :param value:
        :return:
        """
        ...
    
    def __contains__(self, item: str) -> bool:
        """
        Check key contains in that object

        :param item:
        :return:
        """
        ...
    
    def __iter__(self) -> typing.Iterator[str]:
        """
        Iterate over items

        :return:
        """
        ...
    
    def iter_keys(self) -> typing.Generator[typing.Any, None, None]:
        """
        Iterate over keys

        :return:
        """
        ...
    
    def iter_values(self) -> typing.Generator[typing.Any, None, None]:
        """
        Iterate over values

        :return:
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other: TelegramObject) -> bool:
        ...
    


