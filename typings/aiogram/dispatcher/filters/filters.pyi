"""
This type stub file was generated by pyright.
"""

import abc
import typing
from ..handler import FilterObj, Handler

class FilterNotPassed(Exception):
    ...


def wrap_async(func): # -> Awaitable[Any] | AbstractFilter | ((*args: Unknown, **kwargs: Unknown) -> Coroutine[Any, Any, Unknown]):
    ...

def get_filter_spec(dispatcher, filter_: callable): # -> FilterObj:
    ...

def get_filters_spec(dispatcher, filters: typing.Iterable[callable]): # -> list[Unknown]:
    ...

async def execute_filter(filter_: FilterObj, args):
    """
    Helper for executing filter

    :param filter_:
    :param args:
    :return:
    """
    ...

async def check_filters(filters: typing.Iterable[FilterObj], args): # -> dict[Unknown, Unknown]:
    """
    Check list of filters

    :param filters:
    :param args:
    :return:
    """
    ...

class FilterRecord:
    """
    Filters record for factory
    """
    def __init__(self, callback: typing.Union[typing.Callable, AbstractFilter], validator: typing.Optional[typing.Callable] = ..., event_handlers: typing.Optional[typing.Iterable[Handler]] = ..., exclude_event_handlers: typing.Optional[typing.Iterable[Handler]] = ...) -> None:
        ...
    
    def resolve(self, dispatcher, event_handler, full_config): # -> Coroutine[Any, Any, bool] | None:
        ...
    


class AbstractFilter(abc.ABC):
    """
    Abstract class for custom filters.
    """
    @classmethod
    @abc.abstractmethod
    def validate(cls, full_config: typing.Dict[str, typing.Any]) -> typing.Optional[typing.Dict[str, typing.Any]]:
        """
        Validate and parse config.

        This method will be called by the filters factory when you bind this filter.
        Must be overridden.

        :param full_config: dict with arguments passed to handler registrar
        :return: Current filter config
        """
        ...
    
    @abc.abstractmethod
    async def check(self, *args) -> bool:
        """
        Will be called when filters checks.

        This method must be overridden.

        :param args:
        :return:
        """
        ...
    
    async def __call__(self, *args) -> bool:
        ...
    
    def __invert__(self): # -> NotFilter:
        ...
    
    def __and__(self, other): # -> AndFilter:
        ...
    
    def __or__(self, other): # -> OrFilter:
        ...
    


class Filter(AbstractFilter):
    """
    You can make subclasses of that class for custom filters.

    Method ``check`` must be overridden
    """
    @classmethod
    def validate(cls, full_config: typing.Dict[str, typing.Any]) -> typing.Optional[typing.Dict[str, typing.Any]]:
        """
        Here method ``validate`` is optional.
        If you need to use filter from filters factory you need to override this method.

        :param full_config: dict with arguments passed to handler registrar
        :return: Current filter config
        """
        ...
    


class BoundFilter(Filter):
    """
    To easily create your own filters with one parameter, you can inherit from this filter.

    You need to implement ``__init__`` method with single argument related with key attribute
    and ``check`` method where you need to implement filter logic.
    """
    key = ...
    required = ...
    default = ...
    @classmethod
    def validate(cls, full_config: typing.Dict[str, typing.Any]) -> typing.Dict[str, typing.Any]:
        """
        If ``cls.key`` is not :obj:`None` and that is in config returns config with that argument.

        :param full_config:
        :return:
        """
        ...
    


class _LogicFilter(Filter):
    @classmethod
    def validate(cls, full_config: typing.Dict[str, typing.Any]):
        ...
    


class NotFilter(_LogicFilter):
    def __init__(self, target) -> None:
        ...
    
    async def check(self, *args): # -> bool:
        ...
    


class AndFilter(_LogicFilter):
    def __init__(self, *targets) -> None:
        ...
    
    async def check(self, *args): # -> dict[Unknown, Unknown] | bool:
        """
        All filters must return a positive result

        :param args:
        :return:
        """
        ...
    
    def append(self, target): # -> None:
        ...
    


class OrFilter(_LogicFilter):
    def __init__(self, *targets) -> None:
        ...
    
    async def check(self, *args): # -> dict[Unknown, Unknown] | bool:
        """
        One of filters must return a positive result

        :param args:
        :return:
        """
        ...
    
    def append(self, target): # -> None:
        ...
    


