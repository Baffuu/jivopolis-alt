"""
This type stub file was generated by pyright.
"""

import asyncio
import typing
from aiogram.utils.deprecated import renamed_argument
from .filters import AbstractFilter
from .handler import Handler
from .storage import BaseStorage, FSMContext
from .. import types
from ..utils.mixins import ContextInstanceMixin, DataMixin

log = ...
DEFAULT_RATE_LIMIT = ...
class Dispatcher(DataMixin, ContextInstanceMixin):
    """
    Simple Updates dispatcher

    It will process incoming updates: messages, edited messages, channel posts, edited channel posts,
    inline queries, chosen inline results, callback queries, shipping queries, pre-checkout queries.
    """
    def __init__(self, bot, loop=..., storage: typing.Optional[BaseStorage] = ..., run_tasks_by_default: bool = ..., throttling_rate_limit=..., no_throttle_error=..., filters_factory=...) -> None:
        ...
    
    @property
    def loop(self) -> typing.Optional[asyncio.AbstractEventLoop]:
        ...
    
    def __del__(self): # -> None:
        ...
    
    async def skip_updates(self): # -> None:
        """
        You can skip old incoming updates from queue.
        This method is not recommended for using in production.

        Note that the webhook will be deleted!
        """
        ...
    
    async def process_updates(self, updates, fast: bool = ...): # -> list[Any]:
        """
        Process list of updates

        :param updates:
        :param fast:
        :return:
        """
        ...
    
    async def process_update(self, update: types.Update): # -> None:
        """
        Process single update object

        :param update:
        :return:
        """
        ...
    
    async def reset_webhook(self, check=...) -> bool:
        """
        Reset webhook

        :param check: check before deleting
        :return:
        """
        ...
    
    async def start_polling(self, timeout=..., relax=..., limit=..., reset_webhook=..., fast: bool = ..., error_sleep: int = ..., allowed_updates: typing.Optional[typing.List[str]] = ...): # -> None:
        """
        Start long-polling

        :param timeout:
        :param relax:
        :param limit:
        :param reset_webhook:
        :param fast:
        :param error_sleep:
        :param allowed_updates:
        :return:
        """
        ...
    
    def stop_polling(self): # -> None:
        """
        Break long-polling process.

        :return:
        """
        ...
    
    async def wait_closed(self): # -> None:
        """
        Wait for the long-polling to close

        :return:
        """
        ...
    
    def is_polling(self): # -> bool:
        """
        Check if polling is enabled

        :return:
        """
        ...
    
    def register_message_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for message

        .. code-block:: python3

            # This handler works only if state is None (by default).
            dp.register_message_handler(cmd_start, commands=['start', 'about'])
            dp.register_message_handler(entry_point, commands=['setup'])

            # This handler works only if current state is "first_step"
            dp.register_message_handler(step_handler_1, state="first_step")

            # If you want to handle all states by one handler, use `state="*"`.
            dp.register_message_handler(cancel_handler, commands=['cancel'], state="*")
            dp.register_message_handler(cancel_handler, lambda msg: msg.text.lower() == 'cancel', state="*")

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param custom_filters: list of custom filters
        :param kwargs:
        :param state:
        :return: decorated function
        """
        ...
    
    def message_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for message handler

        Examples:

        Simple commands handler:

        .. code-block:: python3

            @dp.message_handler(commands=['start', 'welcome', 'about'])
            async def cmd_handler(message: types.Message):

        Filter messages by regular expression:

        .. code-block:: python3

            @dp.message_handler(regexp='^[a-z]+-[0-9]+')
            async def msg_handler(message: types.Message):

        Filter messages by command regular expression:

        .. code-block:: python3

            @dp.message_handler(filters.RegexpCommandsFilter(regexp_commands=['item_([0-9]*)']))
            async def send_welcome(message: types.Message):

        Filter by content type:

        .. code-block:: python3

            @dp.message_handler(content_types=ContentType.PHOTO | ContentType.DOCUMENT)
            async def audio_handler(message: types.Message):

        Filter by custom function:

        .. code-block:: python3

            @dp.message_handler(lambda message: message.text and 'hello' in message.text.lower())
            async def text_handler(message: types.Message):

        Use multiple filters:

        .. code-block:: python3

            @dp.message_handler(commands=['command'], content_types=ContentType.TEXT)
            async def text_handler(message: types.Message):

        Register multiple filters set for one handler:

        .. code-block:: python3

            @dp.message_handler(commands=['command'])
            @dp.message_handler(lambda message: demojize(message.text) == ':new_moon_with_face:')
            async def text_handler(message: types.Message):

        This handler will be called if the message starts with '/command' OR is some emoji

        By default content_type is :class:`ContentType.TEXT`

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param custom_filters: list of custom filters
        :param kwargs:
        :param state:
        :param run_task: run callback in task (no wait results)
        :return: decorated function
        """
        ...
    
    def register_edited_message_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for edited message

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def edited_message_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for edited message handler

        You can use combination of different handlers

        .. code-block:: python3

            @dp.message_handler()
            @dp.edited_message_handler()
            async def msg_handler(message: types.Message):

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_channel_post_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for channel post

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def channel_post_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for channel post handler

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_edited_channel_post_handler(self, callback, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for edited channel post

        :param callback:
        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def edited_channel_post_handler(self, *custom_filters, commands=..., regexp=..., content_types=..., state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for edited channel post handler

        :param commands: list of commands
        :param regexp: REGEXP
        :param content_types: List of content types.
        :param custom_filters: list of custom filters
        :param state:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_inline_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for inline query

        Example:

        .. code-block:: python3

            dp.register_inline_handler(some_inline_handler, lambda inline_query: True)

        :param callback:
        :param custom_filters: list of custom filters
        :param state:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def inline_handler(self, *custom_filters, state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for inline query handler

        Example:

        .. code-block:: python3

            @dp.inline_handler(lambda inline_query: True)
            async def some_inline_handler(inline_query: types.InlineQuery)

        :param state:
        :param custom_filters: list of custom filters
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return: decorated function
        """
        ...
    
    def register_chosen_inline_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for chosen inline query

        Example:

        .. code-block:: python3

            dp.register_chosen_inline_handler(some_chosen_inline_handler, lambda chosen_inline_result: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return:
        """
        ...
    
    def chosen_inline_handler(self, *custom_filters, state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for chosen inline query handler

        Example:

        .. code-block:: python3

            @dp.chosen_inline_handler(lambda chosen_inline_result: True)
            async def some_chosen_inline_handler(chosen_inline_result: types.ChosenInlineResult)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        :return:
        """
        ...
    
    def register_callback_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for callback query

        Example:

        .. code-block:: python3

            dp.register_callback_query_handler(some_callback_handler, lambda callback_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def callback_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for callback query handler

        Example:

        .. code-block:: python3

            @dp.callback_query_handler(lambda callback_query: True)
            async def some_callback_handler(callback_query: types.CallbackQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_shipping_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for shipping query

        Example:

        .. code-block:: python3

            dp.register_shipping_query_handler(some_shipping_query_handler, lambda shipping_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def shipping_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for shipping query handler

        Example:

        .. code-block:: python3

            @dp.shipping_query_handler(lambda shipping_query: True)
            async def some_shipping_query_handler(shipping_query: types.ShippingQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_pre_checkout_query_handler(self, callback, *custom_filters, state=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for pre-checkout query

        Example:

        .. code-block:: python3

            dp.register_pre_checkout_query_handler(some_pre_checkout_query_handler, lambda shipping_query: True)

        :param callback:
        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def pre_checkout_query_handler(self, *custom_filters, state=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for pre-checkout query handler

        Example:

        .. code-block:: python3

            @dp.pre_checkout_query_handler(lambda shipping_query: True)
            async def some_pre_checkout_query_handler(shipping_query: types.ShippingQuery)

        :param state:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_poll_handler(self, callback, *custom_filters, run_task=..., **kwargs): # -> None:
        """
        Register handler for poll

        Example:

        .. code-block:: python3

            dp.register_poll_handler(some_poll_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def poll_handler(self, *custom_filters, run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for poll handler

        Example:

        .. code-block:: python3

            @dp.poll_handler()
            async def some_poll_handler(poll: types.Poll)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_poll_answer_handler(self, callback, *custom_filters, run_task=..., **kwargs): # -> None:
        """
        Register handler for poll_answer

        Example:

        .. code-block:: python3

            dp.register_poll_answer_handler(some_poll_answer_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def poll_answer_handler(self, *custom_filters, run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for poll_answer handler

        Example:

        .. code-block:: python3

            @dp.poll_answer_handler()
            async def some_poll_answer_handler(poll_answer: types.PollAnswer)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_my_chat_member_handler(self, callback: typing.Callable, *custom_filters, run_task: typing.Optional[bool] = ..., **kwargs) -> None:
        """
        Register handler for my_chat_member

        Example:

        .. code-block:: python3

            dp.register_my_chat_member_handler(some_my_chat_member_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def my_chat_member_handler(self, *custom_filters, run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for my_chat_member handler

        Example:

        .. code-block:: python3

            @dp.my_chat_member_handler()
            async def some_handler(my_chat_member: types.ChatMemberUpdated)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_chat_member_handler(self, callback: typing.Callable, *custom_filters, run_task: typing.Optional[bool] = ..., **kwargs) -> None:
        """
        Register handler for chat_member

        Example:

        .. code-block:: python3

            dp.register_chat_member_handler(some_chat_member_handler)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def chat_member_handler(self, *custom_filters, run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for chat_member handler

        Example:

        .. code-block:: python3

            @dp.chat_member_handler()
            async def some_handler(chat_member: types.ChatMemberUpdated)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_chat_join_request_handler(self, callback: typing.Callable, *custom_filters, run_task: typing.Optional[bool] = ..., **kwargs) -> None:
        """
        Register handler for chat_join_request

        Example:

        .. code-block:: python3

            dp.register_chat_join_request(some_chat_join_request)

        :param callback:
        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def chat_join_request_handler(self, *custom_filters, run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for chat_join_request handler

        Example:

        .. code-block:: python3

            @dp.chat_join_request()
            async def some_handler(chat_member: types.ChatJoinRequest)

        :param custom_filters:
        :param run_task: run callback in task (no wait results)
        :param kwargs:
        """
        ...
    
    def register_errors_handler(self, callback, *custom_filters, exception=..., run_task=..., **kwargs): # -> None:
        """
        Register handler for errors

        :param callback:
        :param exception: you can make handler for specific errors type
        :param run_task: run callback in task (no wait results)
        """
        ...
    
    def errors_handler(self, *custom_filters, exception=..., run_task=..., **kwargs): # -> (callback: Unknown) -> Unknown:
        """
        Decorator for errors handler

        :param exception: you can make handler for specific errors type
        :param run_task: run callback in task (no wait results)
        :return:
        """
        ...
    
    def current_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ...) -> FSMContext:
        """
        Get current state for user in chat as context

        .. code-block:: python3

            with dp.current_state(chat=message.chat.id, user=message.user.id) as state:
                pass

            state = dp.current_state()
            state.set_state('my_state')

        :param chat:
        :param user:
        :return:
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def throttle(self, key, *, rate=..., user_id=..., chat_id=..., no_error=...) -> bool:
        """
        Execute throttling manager.
        Returns True if limit has not exceeded otherwise raises ThrottleError or returns False

        :param key: key in storage
        :param rate: limit (by default is equal to default rate limit)
        :param user_id: user id
        :param chat_id: chat id
        :param no_error: return boolean value instead of raising error
        :return: bool
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def check_key(self, key, chat_id=..., user_id=...): # -> Throttled:
        """
        Get information about key in bucket

        :param key:
        :param chat_id:
        :param user_id:
        :return:
        """
        ...
    
    @renamed_argument(old_name='user', new_name='user_id', until_version='3.0', stacklevel=3)
    @renamed_argument(old_name='chat', new_name='chat_id', until_version='3.0', stacklevel=4)
    async def release_key(self, key, chat_id=..., user_id=...): # -> bool:
        """
        Release blocked key

        :param key:
        :param chat_id:
        :param user_id:
        :return:
        """
        ...
    
    def async_task(self, func): # -> (*args: Unknown, **kwargs: Unknown) -> Coroutine[Any, Any, None]:
        """
        Execute handler as task and return None.
        Use this decorator for slow handlers (with timeouts)

        .. code-block:: python3

            @dp.message_handler(commands=['command'])
            @dp.async_task
            async def cmd_with_timeout(message: types.Message):
                await asyncio.sleep(120)
                return SendMessage(message.chat.id, 'KABOOM').reply(message)

        :param func:
        :return:
        """
        ...
    
    def throttled(self, on_throttled: typing.Optional[typing.Callable] = ..., key=..., rate=..., user_id=..., chat_id=...): # -> (func: Unknown) -> ((*args: Unknown, **kwargs: Unknown) -> Coroutine[Any, Any, Unknown | None]):
        """
        Meta-decorator for throttling.
        Invokes on_throttled if the handler was throttled.

        Example:

        .. code-block:: python3

            async def handler_throttled(message: types.Message, **kwargs):
                await message.answer("Throttled!")

            @dp.throttled(handler_throttled)
            async def some_handler(message: types.Message):
                await message.answer("Didn't throttled!")

        :param on_throttled: the callable object that should be either a function or return a coroutine
        :param key: key in storage
        :param rate: limit (by default is equal to default rate limit)
        :param user_id: user id
        :param chat_id: chat id
        :return: decorator
        """
        ...
    
    def bind_filter(self, callback: typing.Union[typing.Callable, AbstractFilter], validator: typing.Optional[typing.Callable] = ..., event_handlers: typing.Optional[typing.List[Handler]] = ..., exclude_event_handlers: typing.Optional[typing.Iterable[Handler]] = ...): # -> None:
        """
        Register filter

        :param callback: callable or subclass of :obj:`AbstractFilter`
        :param validator: custom validator.
        :param event_handlers: list of instances of :obj:`Handler`
        :param exclude_event_handlers: list of excluded event handlers (:obj:`Handler`)
        """
        ...
    
    def unbind_filter(self, callback: typing.Union[typing.Callable, AbstractFilter]): # -> None:
        """
        Unregister filter

        :param callback: callable of subclass of :obj:`AbstractFilter`
        """
        ...
    
    def setup_middleware(self, middleware): # -> None:
        """
        Setup middleware

        :param middleware:
        :return:
        """
        ...
    


