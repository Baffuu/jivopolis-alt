"""
This type stub file was generated by pyright.
"""

import typing

KEY = ...
LAST_CALL = ...
RATE_LIMIT = ...
RESULT = ...
EXCEEDED_COUNT = ...
DELTA = ...
THROTTLE_MANAGER = ...
class BaseStorage:
    """
    You are able to save current user's state
    and data for all steps in states-storage
    """
    async def close(self):
        """
        You have to override this method and use when application shutdowns.
        Perhaps you would like to save data and etc.

        :return:
        """
        ...
    
    async def wait_closed(self):
        """
        You have to override this method for all asynchronous storages (e.g., Redis).

        :return:
        """
        ...
    
    @classmethod
    def check_address(cls, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ...) -> (typing.Union[str, int], typing.Union[str, int]):
        """
        In all storage's methods chat or user is always required.
        If one of them is not provided, you have to set missing value based on the provided one.

        This method performs the check described above.

        :param chat: chat_id
        :param user: user_id
        :return:
        """
        ...
    
    async def get_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[str] = ...) -> typing.Optional[str]:
        """
        Get current state of user in chat. Return `default` if no record is found.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param default:
        :return:
        """
        ...
    
    async def get_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[typing.Dict] = ...) -> typing.Dict:
        """
        Get state-data for user in chat. Return `default` if no data is provided in storage.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param default:
        :return:
        """
        ...
    
    async def set_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., state: typing.Optional[typing.AnyStr] = ...):
        """
        Set new state for user in chat

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param state:
        """
        ...
    
    async def set_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., data: typing.Dict = ...):
        """
        Set data for user in chat

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param data:
        """
        ...
    
    async def update_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., data: typing.Dict = ..., **kwargs):
        """
        Update data for user in chat

        You can use data parameter or|and kwargs.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param data:
        :param chat:
        :param user:
        :param kwargs:
        :return:
        """
        ...
    
    async def reset_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ...): # -> None:
        """
        Reset data for user in chat.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :return:
        """
        ...
    
    async def reset_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., with_data: typing.Optional[bool] = ...): # -> None:
        """
        Reset state for user in chat.
        You may desire to use this method when finishing conversations.

        Chat or user is always required. If one of this is not presented,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param with_data:
        :return:
        """
        ...
    
    async def finish(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ...): # -> None:
        """
        Finish conversation for user in chat.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :return:
        """
        ...
    
    def has_bucket(self): # -> Literal[False]:
        ...
    
    async def get_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[dict] = ...) -> typing.Dict:
        """
        Get bucket for user in chat. Return `default` if no data is provided in storage.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param default:
        :return:
        """
        ...
    
    async def set_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., bucket: typing.Dict = ...):
        """
        Set bucket for user in chat

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :param bucket:
        """
        ...
    
    async def update_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., bucket: typing.Dict = ..., **kwargs):
        """
        Update bucket for user in chat

        You can use bucket parameter or|and kwargs.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param bucket:
        :param chat:
        :param user:
        :param kwargs:
        :return:
        """
        ...
    
    async def reset_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ...): # -> None:
        """
        Reset bucket dor user in chat.

        Chat or user is always required. If one of them is not provided,
        you have to set missing value based on the provided one.

        :param chat:
        :param user:
        :return:
        """
        ...
    
    @staticmethod
    def resolve_state(value): # -> str | None:
        ...
    


class FSMContext:
    def __init__(self, storage, chat, user) -> None:
        ...
    
    def proxy(self): # -> FSMContextProxy:
        ...
    
    async def get_state(self, default: typing.Optional[str] = ...) -> typing.Optional[str]:
        ...
    
    async def get_data(self, default: typing.Optional[str] = ...) -> typing.Dict:
        ...
    
    async def update_data(self, data: typing.Dict = ..., **kwargs): # -> None:
        ...
    
    async def set_state(self, state: typing.Optional[typing.AnyStr] = ...): # -> None:
        ...
    
    async def set_data(self, data: typing.Dict = ...): # -> None:
        ...
    
    async def reset_state(self, with_data: typing.Optional[bool] = ...): # -> None:
        ...
    
    async def reset_data(self): # -> None:
        ...
    
    async def finish(self): # -> None:
        ...
    


class FSMContextProxy:
    def __init__(self, fsm_context: FSMContext) -> None:
        ...
    
    async def __aenter__(self): # -> Self@FSMContextProxy:
        ...
    
    async def __aexit__(self, exc_type, exc_val, exc_tb): # -> None:
        ...
    
    @classmethod
    async def create(cls, fsm_context: FSMContext): # -> Self@FSMContextProxy:
        """
        :param fsm_context:
        :return:
        """
        ...
    
    async def load(self): # -> None:
        ...
    
    @property
    def state(self): # -> str | None:
        ...
    
    @state.setter
    def state(self, value): # -> None:
        ...
    
    @state.deleter
    def state(self): # -> None:
        ...
    
    async def save(self, force=...): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def get(self, value, default=...): # -> None:
        ...
    
    def setdefault(self, key, default):
        ...
    
    def update(self, data=..., **kwargs): # -> None:
        ...
    
    def pop(self, key, default=...): # -> None:
        ...
    
    def keys(self): # -> dict_keys[Unknown, Unknown]:
        ...
    
    def values(self): # -> dict_values[Unknown, Unknown]:
        ...
    
    def items(self): # -> dict_items[Unknown, Unknown]:
        ...
    
    def as_dict(self): # -> dict[Unknown, Unknown]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __getitem__(self, item):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


class DisabledStorage(BaseStorage):
    """
    Empty storage. Use it if you don't want to use Finite-State Machine
    """
    async def close(self): # -> None:
        ...
    
    async def wait_closed(self): # -> None:
        ...
    
    async def get_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[str] = ...) -> typing.Optional[str]:
        ...
    
    async def get_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[str] = ...) -> typing.Dict:
        ...
    
    async def update_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., data: typing.Dict = ..., **kwargs): # -> None:
        ...
    
    async def set_state(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., state: typing.Optional[typing.AnyStr] = ...): # -> None:
        ...
    
    async def set_data(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., data: typing.Dict = ...): # -> None:
        ...
    
    async def get_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., default: typing.Optional[dict] = ...) -> typing.Dict:
        ...
    
    async def set_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., bucket: typing.Dict = ...): # -> None:
        ...
    
    async def update_bucket(self, *, chat: typing.Union[str, int, None] = ..., user: typing.Union[str, int, None] = ..., bucket: typing.Dict = ..., **kwargs): # -> None:
        ...
    


